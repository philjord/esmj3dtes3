package esmj3dtes3.data.records;

import java.util.ArrayList;
import java.util.List;

import javax.vecmath.Vector3f;

import esmj3d.data.shared.records.RECO;
import esmj3d.data.shared.subrecords.ZString;
import esmmanager.common.data.record.Record;
import esmmanager.common.data.record.Subrecord;
import tools.io.ESMByteConvert;
import utils.convert.ConvertFromNif;

public class PGRD extends RECO
{
	// NOTe this is the name of teh CELL so we can't use it as an editorId
	public ZString EDID = null;

	public DATA DATA;

	public PGRP PGRP;

	public PGRC PGRC;

	public PGRD(Record recordData)
	{
		super(recordData);
		List<Subrecord> subrecords = recordData.getSubrecords();
		for (int i = 0; i < subrecords.size(); i++)
		{
			Subrecord sr = subrecords.get(i);
			byte[] bs = sr.getSubrecordData();

			if (sr.getSubrecordType().equals("NAME"))
			{
				EDID = new ZString(bs);
			}
			else if (sr.getSubrecordType().equals("DATA"))
			{
				DATA = new DATA(bs);
			}
			else if (sr.getSubrecordType().equals("PGRP"))
			{
				PGRP = new PGRP(bs);
			}
			else if (sr.getSubrecordType().equals("PGRC"))
			{
				PGRC = new PGRC(bs);
			}

		}

		/*	File f = new File("c:\\temp\\PJ.esp");
			FileInputStream fis;
			try
			{
				fis = new FileInputStream(f);
				byte[] allData = new byte[10000];
				int readLen = fis.read(allData);
		
		
				System.out.println("readLen" + readLen);
				int offset = 0;
		
				if (allData != null)
				{
					while (offset < readLen)
					{
		
						String recordType = new String(allData, offset + 0, 4);
						System.out.println("recordType " + recordType);
						int recordLength = ESMByteConvert.extractInt(allData, offset + 4);
						System.out.println("recordLength " + recordLength);
		
						if (recordType.equals("PGRD"))
						{
							int offsetSR = 0;
		
							while (offsetSR < recordLength)
							{
								byte[] recordData2 = new byte[recordLength];
								System.arraycopy(allData, offset + 16, recordData2, 0, recordLength);
		
								String subrecordType = new String(recordData2, offsetSR + 0, 4);
								System.out.println("subrecordType " + subrecordType);
								int subrecordLength = ESMByteConvert.extractInt(recordData2, offsetSR + 4);
								System.out.println("subrecordLength " + subrecordLength);
								byte subrecordData[] = new byte[subrecordLength];
								System.arraycopy(recordData2, offsetSR + 8, subrecordData, 0, subrecordLength);
		
								
								 if (subrecordType.equals("PGRP"))
								{
									PGRP = new PGRP(subrecordData);
								}
								else if (subrecordType.equals("PGRC"))
								{
									PGRC = new PGRC(subrecordData);
								}
								
								
								
								offsetSR += 8 + subrecordLength;
							}
		
						}
		
						offset += 16 + recordLength;
					}
				}
		
			}
			catch (FileNotFoundException e)
			{
				e.printStackTrace();
			}
			catch (IOException e)
			{
				e.printStackTrace();
			}*/

	}

	public class PGRC
	{
		/*    PGRC (Path Grid Edges\Links)
			
		4 bytes String = "PGRP"
		4 bytes long = size of sub-record (excluding 8 bytes of header)
		
		--- Repeating structure for each link in cell's pathgrid ----
		
		nothing like the doc, each point has a count of connections, taken from teh connection list, in order
				*/

		public int[] paths;

		public PGRC(byte[] bs)
		{
			paths = new int[bs.length / 4];
			for (int i = 0; i < bs.length / 4; i++)
			{
				paths[i] = ESMByteConvert.extractInt(bs, i * 4 + 0);
			}
		}
	}

	public class PGRP
	{
		/*
		 *   PGRP (Path Grid Points)
			--- Repeating structure for each point in cell's pathgrid ----
			
		    4 bytes long = X-Position of point
		    4 bytes long = Y-Position of point
		    4 bytes long = Z-Position of point
		    4 bytes unknown (possibly flag for coloring /user-placed vs auto-generated)
		       The positions for Path Grid Points are whole numbers (long) and 
		       not floating point numbers, unlike the positions of objects in the CELL records.
		 */

		public ArrayList<PathPoint> pathNodes = new ArrayList<PathPoint>();

		public PGRP(byte[] bs)
		{
			for (int i = 0; i < bs.length; i += 16)
			{
				PathPoint pp = new PathPoint(i, bs);
				pathNodes.add(pp);
			}
		}

	}

	public class PathPoint
	{
		public Vector3f node;
		public byte autogenerated; // autogenerated vs. user coloring flag?
		public byte connectionNum; // number of connections for this point
		public short unknown;

		public PathPoint(int offset, byte[] bs)
		{
			node = new Vector3f(ESMByteConvert.extractInt(bs, offset + 0), //
					ESMByteConvert.extractInt(bs, offset + 4), //
					ESMByteConvert.extractInt(bs, offset + 8));
			ConvertFromNif.toJ3d(node);
			autogenerated = bs[offset + 12];
			connectionNum = bs[offset + 13];
			unknown = (short) ESMByteConvert.extractShort(bs, offset + 14);
		}
	}

	public class DATA
	{
		/*  DATA
		    4 bytes (signed) Int = Cell's X co-ordinates (for exteriors ... for interiors == 0)
		    4 bytes (signed) Int = Cell's Y co-ordinates (for exteriors ... for interiors == 0)
		    2 bytes unknown
		    2 bytes short = (? multiple of ?)total number of number of points in the path grid.
		    */

		public DATA(byte[] bs)
		{

		}

	}
}
